{{+bindTo:partials.standard_nacl_article}}

<section id="release-notes">
<span id="sdk-release-notes"></span><h1 id="release-notes"><span id="sdk-release-notes"></span>Release Notes</h1>
<section id="chrome-pepper-33-branched-on-16-december-2013">
<h2 id="chrome-pepper-33-branched-on-16-december-2013">Chrome/Pepper 33 (branched on 16 December 2013)</h2>
<section id="portable-native-client">
<h3 id="portable-native-client">Portable Native Client</h3>
<ul class="small-gap">
<li>PNaCl&#8217;s default C++ standard library is now LLVM&#8217;s own libc++, based on
LLVM 3.3. This library now supports optional <code>setjmp</code>/<code>longjmp</code> exception
handling (see <a class="reference external" href="https://groups.google.com/forum/#!topic/native-client-discuss/0spfg6O04FM">announcement</a>
for details).</li>
</ul>
</section><section id="sdk">
<h3 id="sdk">SDK</h3>
<ul class="small-gap">
<li>The <code>nacl_io</code> library now includes a FUSE mount.</li>
<li>In the SDK examples, <code>common.js</code> now loads the Release version of the
nexes/pexes that are built (by default).</li>
<li>&#8220;<code>make debug</code>&#8221; and &#8220;<code>make run</code>&#8221; have been fixed on Mac.</li>
</ul>
</section></section><section id="pnacl-enabled-by-default-in-chrome-31-12-nov-2013">
<h2 id="pnacl-enabled-by-default-in-chrome-31-12-nov-2013">PNaCl enabled by default in Chrome 31 (12 Nov 2013)</h2>
<ul class="small-gap">
<li>Portable Native Client (PNaCl) is enabled by default in Chrome 31. See
<a class="reference internal" href="/native-client/nacl-and-pnacl.html"><em>NaCl and PNaCl</em></a> for details on the differences between
NaCl and PNaCl.</li>
<li>The PNaCl ABI has changed from the preview release in Chrome 30.
Pexe modules built with the <code>pepper_30</code> bundle in the SDK must be recompiled
with the <code>pepper_31</code> bundle or later.
As a general rule, we always recommended building applications with the latest
stable bundle in the Native Client SDK.
The PNaCl ABI will remain stable starting with the release of Chrome 31.</li>
<li><p class="first">Additional changes in the Chrome/Pepper 31 release:</p>
<ul class="small-gap">
<li>Updates to the Pepper API, including socket and network support</li>
<li>Improved socket support in the <code>nacl_io</code> library</li>
</ul>
</li>
</ul>
</section><section id="pnacl-in-chrome-30-dev-channel-01-aug-2013">
<h2 id="pnacl-in-chrome-30-dev-channel-01-aug-2013">PNaCl in Chrome 30 Dev channel (01 Aug 2013)</h2>
<ul class="small-gap">
<li>Portable Native Client (PNaCl) is currently available for preview in Chrome
30 (currently in the Dev channel). Apps and sites built with PNaCl can run in
Chrome 30 without an explicit flag.</li>
<li>See <a class="reference external" href="http://www.chromium.org/nativeclient/pnacl/introduction-to-portable-native-client">Introduction to Portable Native Client</a>
for information on developing for PNaCl. More documentation will be available
soon.</li>
<li>Please note that the <a class="reference external" href="http://www.chromium.org/nativeclient/pnacl/bitcode-abi">PNaCl bitcode ABI</a> may still change
before the official public release; if you&#8217;re developing a PNaCl-based
application, be sure to build your code with the latest version of the Native
Client SDK.</li>
<li>Update: PNaCl is not enabled by default in beta or stable versions of M30.</li>
</ul>
</section><section id="pnacl-15-may-2013">
<h2 id="pnacl-15-may-2013">PNaCl (15 May 2013)</h2>
<ul class="small-gap">
<li>Portable Native Client (PNaCl) is currently available for developer preview
in Chrome 29 or higher.</li>
<li>To produce a PNaCl executable (.pexe) file, you must use the pnacl toolchain
in the current <code>pepper_canary</code> bundle. Chrome 29 does not support .pexe
files produced by earlier versions of the pnacl toolchain (that is,
executables compiled with the <code>pepper_28</code> bundle or earlier).</li>
<li>To run an application with a PNaCl module, you must launch Chrome 29 with the
<code>--enable-pnacl</code> flag (for <a class="reference external" href="http://developer.chrome.com/apps/about_apps.html">packaged apps</a>), or the
<code>--enable-nacl</code> flag (for other apps).</li>
<li>When you launch Chrome with the <code>--enable-pnacl</code> flag, Chrome loads a PNaCl
translator in the background. Wait about a minute after you launch Chrome and
check <a class="reference external" href="chrome://nacl">chrome://nacl</a> to verify that the translator loaded.</li>
<li>PNaCl translators are currently available for 32-bit x86, 64-bit x86, and ARM
architectures.</li>
<li>PNaCl applications must use the newlib C library (glibc and dynamic linking
are not supported yet).</li>
<li>The intermediate representation (IR) format may change prior to the release
of PNaCl. If so, you will need to recompile your application with the pnacl
toolchain in a new SDK bundle.</li>
</ul>
</section><section id="pepper-27-12-april-2013">
<h2 id="pepper-27-12-april-2013">Pepper 27 (12 April 2013)</h2>
<p>The Pepper 27 bundle features a significant number of new libraries that have
been incorporated directly into the SDK.</p>
<section id="libraries">
<h3 id="libraries">Libraries</h3>
<ul class="small-gap">
<li><p class="first">A number of libraries from the naclports project have been incorporated
directly into the Native Client SDK. These libraries include:</p>
<ul class="small-gap">
<li>image encoding/decoding: jpeg, tiff, png, webp</li>
<li>multimedia: openal, freealut, ogg, vorbis</li>
<li>XML parsing: tinyxml, xml2</li>
<li>miscellaneous: zlib (general purpose compression), freetype (font
rendering), lua (Lua interpreter)</li>
</ul>
<p>The libraries are located in <code>ports/lib</code>, and the header files are in
<code>ports/include</code>.</p>
</li>
<li>The <code>httpfs</code> filesystem in the nacl_io library now caches content in memory
by default; this improves performance considerably.</li>
<li>For applications compiled with a glibc toolchain, <code>dlopen()</code> can now be
used to open shared libraries that are not specified in an application&#8217;s
Native Client manifest (.nmf) file. This allows applications, for example, to
download a shared object and then use <code>dlopen()</code> to access the shared
object.  The <code>dlopen</code> example has been modified to demonstrate this
functionality: reverse.cc is built into a shared object (.so) file, which is
downloaded and opened using an <code>httpfs</code> mount.</li>
</ul>
</section><section id="examples">
<h3 id="examples">Examples</h3>
<ul class="small-gap">
<li>Each example now has a single <code>index.html</code> file, instead of multiple HTML
files corresponding to NaCl modules built using different toolchains and
configurations. By default, most examples are built using one toolchain
(newlib) and one configuration (Debug). If you build an example using
multiple toolchains or configurations, you can specify which version to run
in Chrome using the query parameters <code>tc</code> and <code>config</code>. For example,
assuming you are serving an example from the local server localhost:5103, you
can run a version of the example built with the glibc toolchain in the
Release configuration by specifying the following URL in Chrome:
<code>http://localhost:5103/index.html?tc=glibc&amp;config=Release</code>. For additional
information about how different NaCl modules are loaded into <code>index.html</code>,
see the <code>common.js</code> file in each example.</li>
</ul>
</section><section id="build-tools-and-toolchains">
<h3 id="build-tools-and-toolchains">Build tools and toolchains</h3>
<ul class="small-gap">
<li>Common makefiles, including <code>tools/common.mk</code>, can now handle source files
located outside of an application&#8217;s root directory. For example, a Makefile
for an application can specify a source file to compile such as
<code>../../some/other/place.cpp</code>.</li>
</ul>
</section></section><section id="pepper-26-29-march-2013">
<h2 id="pepper-26-29-march-2013">Pepper 26 (29 March 2013)</h2>
<p>The Pepper 26 bundle includes a new HTTP filesystem type in the nacl_mounts
library (which has been renamed nacl_io), changes to the example Makefiles, a
simple new 3D example, and a threaded file IO example.</p>
<section id="id1">
<h3 id="id1">Build tools and toolchains</h3>
<ul class="small-gap">
<li><p class="first">Makefiles have been changed significantly:</p>
<ul class="small-gap">
<li>Build commands are now specified in a number of common files
(<code>tools/*.mk</code>), which are included in the Makefiles in the examples.</li>
<li>By default, make displays a simplified list of build steps (e.g., <code>CC
newlib/Debug/hello_world_x86_32.o</code>) rather than the actual build commands.
To see the actual build commands, run <code>make V=1</code>.</li>
<li>By default, most examples are built using one toolchain (newlib) and one
configuration (Debug). To build an example using a different toolchain or
configuration, run <code>make</code> with the parameters <code>TOOLCHAIN=&lt;x&gt;</code> or
<code>CONFIG=&lt;y&gt;</code>.  You can also run make <code>all_versions</code> to build an example
with all toolchains.</li>
</ul>
</li>
<li>Header files have been moved out of the toolchains. All toolchains now share
the same set of header files as host builds. Previously host and NaCl builds
used different headers, which could cause build problems.</li>
</ul>
</section><section id="id2">
<h3 id="id2">Libraries</h3>
<ul class="small-gap">
<li>The nacl_mounts library has been renamed <strong>nacl_io</strong>, and has been expanded
with a new type of mount, httpfs, which can be used to read URLs via HTTP.
For details see <code>include/nacl_io/nacl_io.h</code>, as well as the
<code>hello_nacl_io</code> example.</li>
</ul>
</section><section id="id3">
<h3 id="id3">Examples</h3>
<ul class="small-gap">
<li>A new example, <strong>hello_world_instance3d</strong>, has been added to demonstrate a
simplified 3D app.</li>
<li>The <strong>file_io</strong> example has been rewritten to do all file operations on a
thread.  The example demonstrates how to use the MessageLoop API and blocking
callbacks on a thread.</li>
</ul>
</section><section id="general">
<h3 id="general">General</h3>
<ul class="small-gap">
<li>Old bundles (<code>pepper_20</code> and earlier) have been removed from the Native
Client SDK Manifest, and will no longer be updated by the <code>naclsdk</code>
command.</li>
</ul>
</section></section><section id="pepper-25-21-december-2012">
<h2 id="pepper-25-21-december-2012">Pepper 25 (21 December 2012)</h2>
<p>The Pepper 25 bundle features an ARM toolchain to build Native Client modules
for ARM devices, two new Pepper APIs (including the MessageLoop API, which lets
you make Pepper calls on background threads), two new libraries (nacl_mounts,
which provides a virtual file system that you can use with standard C file
operations, and ppapi_main, which lets you implement a Native Client module
using a simple ppapi_main function), and two new examples that demonstrate how
to use the nacl_mounts and ppapi_main libraries.</p>
<section id="id4">
<h3 id="id4">Build tools and toolchains</h3>
<ul class="small-gap">
<li><p class="first">The SDK includes a new toolchain to build Native Client executables (.nexe
files) for <strong>ARM devices</strong>.</p>
<ul class="small-gap">
<li>Currently the ARM toolchain can only be used to compile modules that use
the <a class="reference internal" href="/native-client/devguide/devcycle/dynamic-loading.html#c-libraries"><em>newlib C library</em></a>. You cannot use the ARM toolchain
to compile modules that use the glibc library.</li>
<li>The ARM toolchain is in the directory
<code>pepper_25/toolchain/&lt;host&gt;_arm_newlib</code>.  The bin subdirectory contains
the compiler (<code>arm-nacl-gcc</code>), the linker (<code>arm-nacl-g++</code>), and the
other tools in the toolchain.</li>
<li>Take a look at the <code>hello_world</code> example to see how to use the ARM
toolchain. Go to <code>examples/hello_world</code> and run <code>make</code>. When the build
finishes, the newlib/Debug and newlib/Release subdirectories will contain
.nexe files for the x86-32, x86-64, and ARM target architecutes, and a
Native Client manifest (.nmf file) that references those three .nexe files.</li>
</ul>
</li>
<li>The simple web server included in the SDK, <code>httpd.py</code>, has been moved from
the <code>examples/</code> directory to the <code>tools/</code> directory. On Windows, you can
run <code>httpd.cmd</code> (in the <code>examples/</code> directory) to start the server.</li>
</ul>
</section><section id="ppapi">
<h3 id="ppapi">PPAPI</h3>
<p>Pepper 25 includes two new APIs:</p>
<ul class="small-gap">
<li>The <a class="reference external" href="https://developers.google.com/native-client/dev/pepperc/struct_p_p_b___console__1__0">Console API</a>
lets your module log messages to the JavaScript console in the Chrome browser.</li>
<li>The <a class="reference external" href="https://developers.google.com/native-client/dev/peppercpp/classpp_1_1_message_loop">MessageLoop</a>
API lets your module make PPAPI calls on a background thread.  Once you&#8217;ve
created a message loop resource, attached it to a thread, and run it, you can
post work to the thread, including completion callbacks for asynchronous
operations. For a C++ example of how to use the MessageLoop API,
see <code>pepper_25/include/ppapi/utility/threading/simple_thread.h</code>. Note that
you cannot make asynchronous PPAPI calls on a background thread without
creating and using a message loop.</li>
</ul>
</section><section id="id5">
<h3 id="id5">Libraries</h3>
<p>The SDK includes two new libraries:</p>
<ul class="small-gap">
<li><p class="first">The <strong>nacl_mounts</strong> library provides a virtual file system that your module
can &#8220;mount&#8221; in a given directory tree. The file system can be one of several
types:</p>
<ul class="small-gap">
<li>&#8220;memfs&#8221; is an in-memory file system,</li>
<li>&#8220;dev&#8221; is a file system with various utility nodes (e.g., <code>/dev/null</code>,
<code>/dev/console[0-3]</code>, <code>/dev/tty</code>), and</li>
<li>&#8220;html5fs&#8221; is a persistent file system.</li>
</ul>
<p>Once you&#8217;ve mounted a file system in your module, you can use standard C
library file operations: fopen, fread, fwrite, fseek, and fclose. How those
operations are performed depends on the type of file system (e.g., for
html5fs, the operations are performed using the Pepper FileIO API). For a
list of the types of file systems you can mount, see
include/nacl_mounts/nacl_mounts.h. For an example of how to use nacl_mounts,
see examples/hello_nacl_mounts. Note that html5fs is subject to the same
constraints as persistent <a class="reference internal" href="/native-client/devguide/coding/file-io.html#devguide-coding-fileio"><em>local file IO</em></a> in
Chrome (for example, prior to using an html5fs file system, you must <a class="reference external" href="enabling_file_access">enable
local file IO</a>).</p>
</li>
<li>The <strong>ppapi_main</strong> library simplifies the creation of a NaCl module by
providing a familiar C programming environment. With this library, your
module can have a simple entry point called ppapi_main(), which is similar to
the standard C main() function, complete with argc and argv[] parameters.
Your module can also use standard C functions such as printf(), fopen(), and
fwrite(). For details see include/ppapi_main/ppapi_main.h. For an example of
how to use ppapi_main, see examples/hello_world_stdio.</li>
</ul>
<p>Header files for the new libraries are in the <code>include/</code> directory, source
files are in the <code>src/</code> directory, and compiled libraries are in the <code>lib/</code>
directory.</p>
</section><section id="id6">
<h3 id="id6">Examples</h3>
<ul class="small-gap">
<li><p class="first">The SDK includes two new examples:</p>
<ul class="small-gap">
<li><strong>hello_nacl_mounts</strong> illustrates how to use standard C library file
operations in a Native Client module through the use of the nacl_mounts
library.</li>
<li><strong>hello_world_stdio</strong> illustrates how to implement a Native Client module
with a ppapi_main() function, and how to write to STDOUT and STDERR in a
module, through the use of the nacl_mounts and ppapi_main libraries. This
example makes it easy for new users to get started with Native Client by
letting them start making changes in a familiar C environment.</li>
</ul>
</li>
<li><p class="first">With a few exceptions, the Makefile for each example now builds the following
versions of each example:</p>
<ul class="small-gap">
<li>glibc toolchain: 32-bit and 64-bit .nexes for the x86 target architecture</li>
<li>newlib toolchain: 32-bit and 64-bit .nexes for the x86 target architecture,
and ARM .nexe for the ARM architecture</li>
<li>pnacl toolchain: .pexe (which is subsequently tranlsated to .nexes for the
x86-32, x86-64, and ARM architectures)</li>
<li>hosted toolchain: .so or .dll (to be executed as a Pepper plug-in in
Chrome)</li>
</ul>
</li>
<li>Additionally, each version is built in both a Debug and a Release
configuration.</li>
<li>The Makefile for each example includes two new targets: <code>make RUN</code> and
<code>make LAUNCH</code>. These targets, which are interchangeable, launch a local
server and an instance of Chrome to run an example. When the instance of
Chrome is closed, the local server is shut down as well.</li>
<li>The hello_world_stdio example includes a simplified Makefile that only lists
source dependencies, and invokes the build rules in a separate file
(common.mk).</li>
</ul>
</section></section><section id="pepper-24-5-december-2012">
<h2 id="pepper-24-5-december-2012">Pepper 24 (5 December 2012)</h2>
<p>The Pepper 24 bundle features a new, experimental toolchain called PNaCl (short
for &#8220;Portable Native Client&#8221;), a new library (pthreads-win32) for the Windows
SDK, and an expanded list of attributes for Pepper 3D contexts that lets
applications specify a GPU preference for low power or performance.</p>
<section id="id7">
<h3 id="id7">Build tools and toolchains</h3>
<ul class="small-gap">
<li>The SDK includes a new, experimental toolchain called <a class="reference external" href="http://nativeclient.googlecode.com/svn/data/site/pnacl.pdf">PNaCl</a> (pronounced
&#8220;pinnacle&#8221;). The PNaCl toolchain produces architecture-independent executable
files (.pexe files). Chrome doesn&#8217;t yet support .pexe files directly, but if
you want to experiment with this early preview of PNaCl, the toolchain
includes a tool to translate .pexe files into architecture-specific .nexe
files. Take a look at the <code>hello_world</code> example to see how to build a .pexe
file and translate it into multiple .nexe files. Note that PNaCl is currently
restricted to the newlib C standard library – if your application uses glibc,
you can&#8217;t build it with PNaCl.</li>
<li>The <code>create_nmf.py</code> script uses ELF headers (rather than file names) to
determine the architecture of .nexe files. That means you can change the
names of your .nexe files and <code>create_nmf.py</code> will still be able to
generate the appropriate Native Client manifest file for your application.</li>
</ul>
</section><section id="id8">
<h3 id="id8">Examples</h3>
<ul class="small-gap">
<li>The SDK examples now build with four toolchains: the glibc and newlib
toolchains, the experimental PNaCl toolchain, and the hosted toolchain on
your development machine. Within each toolchain build, each example also
builds both a debug and a release version.</li>
<li>The example Makefiles use dependency (.d) files to enable incremental builds.</li>
<li>The pong example has been cleaned up and modified to run more smoothly. The
drawing function is now set up as the Flush() callback, which allows 2D
drawing to occur as quickly as possible.</li>
</ul>
</section><section id="id9">
<h3 id="id9">PPAPI</h3>
<ul class="small-gap">
<li>When creating a 3D rendering context, the <a class="reference external" href="https://developers.google.com/native-client/dev/pepperc/group___enums#ga7df48e1c55f6401beea2a1b9c07967e8">attribute list</a>
for the context can specify whether to prefer low power or performance for
the GPU. Contexts with a low power preference may be created on an integrated
GPU; contexts with a performance preference may be created on a discrete GPU.</li>
</ul>
</section><section id="windows-sdk">
<h3 id="windows-sdk">Windows SDK</h3>
<ul class="small-gap">
<li>The Windows SDK includes the pthreads-win32 library to assist in porting from
win32 code. You can use this library when developing your module as a Pepper
plug-in (.dll). See pepper_24/include/win/pthread.h and
pepper_24/src/pthread/README for additional information.</li>
<li>The update utility naclsdk.bat works when it is run from a path with spaces.</li>
</ul>
</section></section><section id="pepper-23-15-october-2012">
<h2 id="pepper-23-15-october-2012">Pepper 23 (15 October 2012)</h2>
<p>The Pepper 23 bundle includes support for the nacl-gdb debugger on Mac and
32-bit Windows, resources to enable hosted development on Linux, and changes to
make the SDK examples compliant with version 2 of the Chrome Web Store manifest
file format.</p>
<section id="tools">
<h3 id="tools">Tools</h3>
<ul class="small-gap">
<li>The <a class="reference external" href="https://developers.google.com/native-client/pepper23/devguide/devcycle/debugging#gdb">nacl-gdb debugger</a>
now works on all systems (Mac, Windows, and Linux).</li>
<li>The output of the SDK update utility has been simplified. When you run the
command <code>naclsdk list</code>, the utility displays one line for each available
bundle, annotated with an &#8220;<code>I</code>&#8221; if the bundle is already installed on your
system, and a &#8220;<code>*</code>&#8221; if the bundle has an update available. To see full
information about a bundle, use the command <code>naclsdk info &lt;bundle&gt;</code> (for
example, <code>naclsdk info pepper_28</code>).</li>
</ul>
</section><section id="linux-sdk">
<h3 id="linux-sdk">Linux SDK</h3>
<ul class="small-gap">
<li><p class="first">Developers using the Linux SDK now have resources, including pre-built
libraries and example Makefiles, that make it easier to <strong>build a module as a
Pepper plugin</strong> (sometimes called a &#8220;trusted&#8221; or &#8220;in-process&#8221; plugin) using
the native C/C++ compiler on their development system. In essence this makes
developing a Native Client module a two-step process:</p>
<ol class="arabic simple">
<li>Build the module into a shared library (.so file) using your system&#8217;s
C/C++ compiler. Test and debug the .so file using the tools in your normal
development environment.</li>
<li>Build the module into a .nexe file using the compiler from one of the
Native Client toolchains in the SDK (nacl-gcc or nacl-g++). Test and debug
the .nexe file using nacl-gdb.</li>
</ol>
<p>This two step development process has many benefits—in particular, you can
use the compilers, debuggers, profilers, and other tools that you&#8217;re already
familiar with. But there are a few potential issues to keep in mind:</p>
<ul class="small-gap">
<li>Chrome uses different threading models for trusted plugins and Native
Client modules.</li>
<li>Certain operations such as platform-specific library calls and system calls
may succeed during trusted development, but fail in Native Client.</li>
</ul>
<p>Here are the resources you can use to build your module into a Pepper plugin:</p>
<ul class="small-gap">
<li>header files are in <code>pepper_23/include</code></li>
<li>source files are in <code>pepper_23/src</code></li>
<li>pre-built libraries are in <code>pepper_23/lib</code></li>
</ul>
<p>You can now build and run most of the examples in the SDK as Pepper plugins.</p>
<ul class="small-gap">
<li>Look at the example Makefiles or run <code>make</code> in the example directories to
see the commands and flags used to build modules as Pepper plugins.</li>
<li>Run <code>make LAUNCH</code> in the example directories to see how to use the
<code>--register-pepper-plugins</code> argument to load a Pepper plugin in Chrome.
Note that you must set the <code>CHROME_PATH</code> environment variable and start a
<a class="reference internal" href="/native-client/devguide/devcycle/running.html#web-server"><em>local server</em></a> prior to running this command.</li>
</ul>
</li>
</ul>
</section><section id="id10">
<h3 id="id10">Examples</h3>
<ul class="small-gap">
<li>On Linux and Windows systems, most of the examples now build with three
toolchains: the Native Client glibc and newlib toolchains, and the native
toolchain on the host system. Modules built with the native toolchain on the
host system can only run as Pepper plugins.</li>
<li>All examples in the SDK now comply with version 2 of the Chrome Web Store
<a class="reference external" href="http://developer.chrome.com/extensions/manifest.html">manifest file format</a>. By default,
applications that use version 2 of the manifest file format apply a strict
<a class="reference external" href="http://developer.chrome.com/extensions/contentSecurityPolicy.html">content security policy</a>, which
includes a restriction against inline JavaScript. This restriction prohibits
both inline <code>&lt;script&gt;</code> blocks and inline event handlers (e.g., <code>&lt;button
onclick=&quot;...&quot;&gt;</code>).  See <a class="reference external" href="http://developer.chrome.com/extensions/manifestVersion.html">Manifest Version</a> for a list of
changes between version 1 and version 2 of the manifest file format, and a
support schedule for applications that use version 1.</li>
</ul>
</section><section id="id11">
<h3 id="id11">PPAPI</h3>
<ul class="small-gap">
<li><a class="reference external" href="https://developers.google.com/native-client/pepper23/pepperc/group___enums#ga21b811ac0484a214a8751aa3e1c959d9">PP_InputEvent_Modifier</a>
has two new enum values (_ISLEFT and _ISRIGHT).</li>
<li>The memory leak in the <a class="reference external" href="https://developers.google.com/native-client/pepper23/pepperc/struct_p_p_b___web_socket__1__0">WebSocket</a>
API has been fixed.</li>
</ul>
</section></section><section id="pepper-22-22-august-2012">
<h2 id="pepper-22-22-august-2012">Pepper 22 (22 August 2012)</h2>
<p>The Pepper 22 bundle includes a <strong>command-line debugger</strong>, resources to enable
<strong>hosted development on Windows</strong>, and changes to the example Makefiles (each
example now builds both a debug and a release version).</p>
<section id="id12">
<h3 id="id12">Tools</h3>
<ul class="small-gap">
<li>The SDK now includes a <strong>command-line debugger</strong> that you can use to debug
Native Client modules. See <a class="reference internal" href="/native-client/devguide/devcycle/debugging.html#devcycle-debugging"><em>Debugging with nacl-gdb</em></a> for instructions on how to use this debugger. For now,
nacl-gdb only works on 64-bit Windows, 64-bit Linux, and 32-bit Linux
systems. Support for Mac and 32-bit Windows systems will be added soon.</li>
</ul>
</section><section id="id13">
<h3 id="id13">Windows SDK</h3>
<ul class="small-gap">
<li><p class="first">Developers using the Windows SDK can now <strong>build a module as a Pepper
plugin</strong> (sometimes called a &#8220;trusted&#8221; or &#8220;in-process&#8221; plugin) using the
native C/C++ compiler on their development system. In essence this makes
developing a Native Client module a two-step process:</p>
<ol class="arabic simple">
<li>Build the module into a DLL using your system&#8217;s C/C++ compiler. Test and
debug the DLL using the tools in your normal development environment.</li>
<li>Build the module into a .nexe using the compiler from one of the Native
Client toolchains in the SDK (nacl-gcc or nacl-g++). Test and debug the
.nexe using nacl-gdb.</li>
</ol>
<p>This two step development process has many benefits—in particular, you can
use the compilers, debuggers, profilers, and other tools that you&#8217;re already
familiar with. But there are a few potential issues to keep in mind:</p>
<ul class="small-gap">
<li>Some libraries that are commonly used with Native Client may not build
easily on Windows.</li>
<li>You may need to put in extra effort to get source code to compile with
multiple compilers, e.g., Microsoft Visual Studio and GCC.</li>
<li>Chrome uses different threading models for trusted plugins and Native
Client modules.</li>
<li>Certain operations such as platform-specific library calls and system calls
may succeed during trusted development, but fail in Native Client.</li>
</ul>
<p>Here are the resources you can use to build your module into a DLL:</p>
<ul class="small-gap">
<li>header files are in <code>pepper_22\include</code></li>
<li>source files are in <code>pepper_22\src</code></li>
<li>pre-built libraries are in <code>pepper_22\lib</code></li>
</ul>
</li>
<li>A Visual Studio add-in will be available in the near future with
configurations that include platforms for both Pepper plugins and NaCl
modules.</li>
</ul>
<aside class="note">
<strong>Note:</strong> It&#8217;s also possible to build a module as a trusted plugin on Mac and
Linux systems, but doing so requires more work because the SDK does not yet
include the above resources (library source files and pre-built libraries)
for Mac and Linux systems. To build and debug a trusted plugin on Mac and
Linux systems, you need to <a class="reference external" href="http://dev.chromium.org/developers/how-tos/get-the-code">get the Chromium code</a> and then follow
the <a class="reference external" href="http://www.chromium.org/nativeclient/how-tos/debugging-documentation/debugging-a-trusted-plugin/trusted-debugging-on-mac">Mac instructions</a>
or <a class="reference external" href="http://www.chromium.org/nativeclient/how-tos/debugging-documentation/debugging-a-trusted-plugin/debugging-a-trusted-plugin-on-linux">Linux instructions</a>.
In the future, the SDK will include resources for hosted development on Mac
and Linux as well as Windows.
</aside>
</section><section id="id14">
<h3 id="id14">Examples</h3>
<ul class="small-gap">
<li>Each example in the SDK now builds both a debug and a release version. As
before, most examples also build newlib and glibc versions, which means that
there are now four versions for each example. Take a look at the Makefiles in
the examples to see the compiler flags that are used for debug and release
versions. For a description of those flags, see <a class="reference internal" href="/native-client/devguide/devcycle/building.html#compile-flags"><em>Compile flags for
different development scenarios</em></a>.</li>
<li>Comments have been added to common.js, which is used in all the examples. The
JavaScript in common.js inserts an &lt;embed&gt; element that loads the NaCl module
in each example&#8217;s web page, attaches event listeners to monitor the loading
of the module, and implements handleMessage() to respond to messages sent
from the NaCl module to the JavaScript side of the application</li>
</ul>
</section><section id="id15">
<h3 id="id15">PPAPI</h3>
<ul class="small-gap">
<li>The <code>CompletionCallbackFactory</code> class template now takes a thread traits
class as its second parameter. For details see the <a class="reference external" href="https://developers.google.com/native-client/pepper22/peppercpp/classpp_1_1_completion_callback_factory#details">CompletionCallbackFactory
class template reference</a>.</li>
</ul>
</section></section></section>

{{/partials.standard_nacl_article}}
